\documentclass{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{url}

\title{Development Plan\\\progname}

\author{\authname}

\date{}

\input{../Comments}
\input{../Common}

\begin{document}

\maketitle

\begin{table}[hp]
\caption{Revision History} \label{TblRevisionHistory}
\begin{tabularx}{\textwidth}{llX}
\toprule
\textbf{Date} & \textbf{Developer(s)} & \textbf{Change}\\
\midrule
2024/09/19 & Hemraj Bhatt & Added content to sections 7, 8 and the appendix. Created reference page\\
Date2 & Name(s) & Description of changes\\
... & ... & ...\\
\bottomrule
\end{tabularx}
\end{table}

\wss{Put your introductory blurb here.}

\section{Team Meeting Plan}

\section{Team Communication Plan}

\section{Team Member Roles}

\section{Workflow Plan}

\begin{itemize}
	\item How will you be using git, including branches, pull request, etc.?
	\item How will you be managing issues, including template issues, issue
	classificaiton, etc.?
\end{itemize}

\section{Proof of Concept Demonstration Plan}

Developing an online multiplayer variant of Yahtzee presents several risks that could impact the success of the project. One significant risk is the inability to implement online multiplayer functionality with short response times, which is crucial for maintaining a smooth and enjoyable user experience, and to allow for simultaneous dice rolls. Delays or lags in response times could frustrate players and negatively affect gameplay, and hinder the player interaction that the game aims to provide. Another risk is not being able to correctly implement the complex Yahtzee scoring system, which could result in incorrect outcomes or unfair gameplay. Ensuring that the game accurately tracks scores according to the traditional rules is essential for user satisfaction. Finally, failing to implement the basic Yahtzee mechanics, such as rolling dice, re-rolling, and selecting scoring categories, could hinder the core gameplay. If these foundational elements are not properly developed, the entire game experience could become dysfunctional and unplayable. \\

To address the key risks in developing an online multiplayer Yahtzee variant, the proof of concept demo will focus on demonstrating the core functionality required to overcome these challenges. First, it should showcase the implementation of online multiplayer with fast response times, ensuring real-time interaction between players without noticeable lag. This will prove that the game can handle smooth, synchronized gameplay across different devices. Next, the demo must include a fully functional Yahtzee scoring system, correctly calculating scores for all possible combinations, like full house, straights, and Yahtzees, to show accuracy and reliability in scoring. Lastly, the demo should feature the basic Yahtzee mechanics, such as rolling dice, re-rolling up to two times, and selecting score categories, all working seamlessly. By focusing on these critical features, the demo will provide confidence that the project can overcome the identified risks and deliver a functional and enjoyable multiplayer experience.\\

\section{Expected Technology}

For this project, the online multiplayer variant of Yahtzee will be developed using the Godot game engine with GDScript as the primary programming language. GDScript is specifically designed for Godot and offers an easy-to-read, Python-like syntax, making it ideal for rapid game development and ensuring seamless integration with the Godot engine's core features. The Godot engine will provide the necessary framework for game physics, rendering, input handling, and networking, allowing us to focus on game-specific functionality such as the multiplayer interaction, Yahtzee mechanics, and scoring system. \\

External libraries may be utilized to support features such as real-time multiplayer synchronization and latency management. For example, Godot has built-in networking features, but depending on the complexity and performance requirements of the game, we may need to integrate additional libraries or APIs to enhance real-time communication between clients. As part of the development, we will implement certain major components ourselves, such as the Yahtzee scoring system and game logic, despite the existence of general-purpose libraries. This is because the game mechanics are fairly specific and require careful tuning to ensure proper scoring and gameplay flow, which can be more effectively managed through custom implementations. \\

Additionally, we will investigate tools for unit testing in GDScript and Godot, ensuring game logic is consistently validated, while code coverage tools will be explored to measure the extent of our test cases. Although Continuous Integration (CI) is typically less emphasized in game development, incorporating simple CI pipelines could benefit our project, ensuring that new builds are tested regularly for performance and functionality. Performance measuring tools like Godot's built-in profiler will be used to monitor frame rates and resource consumption, critical for ensuring smooth, responsive multiplayer gameplay. Lastly, we will be using version control through Git, integrated with platforms like GitHub for collaboration, which will facilitate efficient management of code changes and team contributions. \\

\section{Coding Standard}


The coding guidelines mentioned below will allow for an unfirm codebase and proper collaboration between developers. The guidelines set are universally accepted, which ensures these guidelines meet industry standards.

\begin{itemize}

  \item Use ``int'' rather than unsigned types. \texttt{int} is commonly used in C\# and interacts more easily with other libraries. Exceptions apply only for documentation specific to unsigned data types. [1]
  \item Class and method names should always be in Pascal Case
  \begin{itemize}
    \item Ex: PascalCase
  \end{itemize}
  \item Method arguments and local variables should always be in Camel Case
  \begin{itemize}
    \item Ex: camelCase
  \end{itemize}
  \item Employ abstraction, encapsulation, inheritance and polymorphism

  \begin{itemize}
    \item Abstraction: Model the relevant attributes and interactions of entities as classes to define an abstract representation of a system. Use interfaces or abstract classes to provide a blueprint for other classes without revealing implementation details. [2]
    \item Encapsulation: Hide the internal state and functionality of an object, allowing access only through a public set of functions. Use private fields to hide an object's internal state. Provide public properties or methods (get and set) to access or modify the private fields in a controlled way, ensuring safe interaction with the object. [2]
    \item Inheritance: Create new abstractions based on existing abstractions. Reuse common functionality from the base class while allowing the derived class to add or override methods or properties. [2]
    \item Polymorphism: Implement inherited properties or methods in different ways across multiple abstractions. Use interfaces or abstract classes to define common methods that can be implemented differently in each class. [2]

  \end{itemize}

\item Write code with clarity and simplicity in mind
\item Avoid overly complex and convoluted code logic
\item Comments should be consice and to the point
\item Code should be formatted appropriately
\item Hard coded constants should be avaided, employ symbolic names and use configuration files 
\item Any code taken from external sources must be sufficiently cited through comments
\begin{itemize}
  \item Include links to webpages for any external resources
  \item Include input and output for any AI-aided code
\end{itemize}


\end{itemize}


\newpage

\section{Project Scheduling}

The team has decided to employ a Gantt chart to schedule the project. A Gantt chart provides a way to depict the duration, completion percentage, and leads of tasks in a visual manner. Due to these benefits, deadlines are met due to the duration of a task being enforced by start and end dates. It also allows for effective communication as others know who to refer to if there is an issue pertaining to a certain task due to the leads being listed. All in all, a Gantt chart provides great facilities to effectively plan out a project. \\

The team will also implement a backlog for our development which will be featured in our readme file on github to aid potential contributors. This will allow them to understand which features have been implemented and which are still in development. This will be in addition to utilizing GitHub project boards.\\

Gantt Chart: \href{https://mcmasteru365-my.sharepoint.com/:x:/g/personal/bhatth14_mcmaster_ca/ESjvjVJfZflPvcV8xfFiPxEBNGdj_fdNWy0EyGGiqIbAEw?e=9wUfQj}{Link}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741}

\input{../Reflection.tex}

\begin{enumerate}
    \item  \textbf {Why is it important to create a development plan prior to starting the
    project?}

    A development plan is essential when taking on any sort of project. It allows for the team to set a clear set of goals and milestones while also defining the project's scope. It creates a baseline of expectations for each team member and reduces any confusion about the team's plan as a high-level plan is detailed within the development plan. Without a development plan, a direction for the team is not set which in both the short and long term will cause issues that will eventually lead to missed deadlines and poor quality of work.
    
    \item  \textbf {In your opinion, what are the advantages and disadvantages of using
    CI/CD?}

    In our scenario, the team is creating a game using Godot, an open-source game engine. Therefore, there are some issues that present themselves. One is, performing automated testing, as it is more complex due to the need for graphical tests and user input simulations, which aren't easily automated in standard CI/CD pipelines. Another issue with CI/CD is that they are complex to set up and maintain as the system must remain updated, secure, and functional.

    However, there are still benefits to employing CI/CI pipelines as it promotes collaboration. Everyone is always working on the most up-to-date version which reduces commit conflicts and new features not working due to code logic being altered in an unpulled commit. It also allows new features and fixes to be pushed to production more quickly and reliably which enhances software quality and user satisfaction.

    Overall, implementing Continuous Integration (CI) and Continuous Deployment does provide a sizable benefit to most projects. However, as mentioned above, it cannot be used in certain circumstances. It may be ideal but it is not feasible. In the team's case, CI/CD may not be beneficial and impractical but we can still use aspects of CI/CD in our methodology.    
    \item  \textbf {What disagreements did your group have in this deliverable, if any,
    and how did you resolve them?}

    When constructing the development plan, the team faced no disagreements. Due to the area of the project being outside of our expertise, the team was open to suggestions on how the project could be developed. Due to close to zero experience in game development, when researching important tools that would be used to develop the game such as what game engine to use we were able to go off separately on our own and research the pros and cons of certain game engines such as Unity and Godot. Doing this allowed each member to understand the pros and cons of different game engines and were then able to conclude which game engine to use without much issue.
\end{enumerate}

\newpage{}

\section*{Appendix --- References}

\begin{flushleft}
  [1] B. Wagner, "C\# Coding Conventions," \textit{learn.microsoft.com}, Available: \url{https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions}.
  \newline
  [2] B. Wagner, "Object-Oriented Programming C\#," \textit{learn.microsoft.com}, Available: \url{https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop}.
\end{flushleft}

\end{document}