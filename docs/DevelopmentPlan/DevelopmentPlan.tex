\documentclass{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{changepage}

\title{Development Plan\\\progname\\\href{https://github.com/John-Popovici/duel-of-the-eights.git}{GitHub}}

\author{\authname}


\date{}

\input{../Comments}
\input{../Common}

\begin{document}

\maketitle

\begin{table}[hp]
\caption{Revision History} \label{TblRevisionHistory}
\begin{tabularx}{\textwidth}{llX}
\toprule
\textbf{Date} & \textbf{Developer(s)} & \textbf{Change}\\
\midrule
2024/09/19 & Hemraj Bhatt & Added content to sections 7, 8 and the appendix. Created reference page\\
2024/09/20 & Nigel Moses, Naishan Guo & Added content to sections 5 and 6.\\
2024/09/23 & Isaac Giles & Added content to sections 1-4\\
... & ... & ...\\
\bottomrule
\end{tabularx}
\end{table}

\section{Team Meeting Plan}

Team will meet every Friday morning at 9am via Microsoft Teams meeting for 30-60 minutes for general discussions. Further meetings will be suggested in Microsoft Teams chat when team members feel that an additional meeting is needed.

\section{Team Communication Plan}

Team will communicate via Microsoft Teams messaging for all baseline communication needs. We will also use Microsoft Teams to setup team calls for both recurring meetings and spontaneous meetings that come up when needed.

\section{Team Member Roles}

\begin{center}
  \begin{tabular}{ |c|c|c| } 
   \hline
   \textbf{Person} & \textbf{Role} & \textbf{Responsibilities} \\ 
   \hline
   John Popovici & Developer \& Team Liaison & \multirow{5}*{\shortstack{Writing code, working on \\documentation, testing, reviewing \\code, creating detailed issues \\and bug reports}} \\ 
   \cline{1-2}
   Hemraj Bhatt & \multirow{4}*{Developer} & \\ 
   \cline{1-1}
   Isaac Giles & & \\ 
   \cline{1-1}
   Nai Shan Guo & & \\ 
   \cline{1-1}
   Nigel Moses & & \\ 
   \hline
  \end{tabular}
  \end{center}

\section{Workflow Plan}

The general workflow for the team follows from team meetings where we will assess where we are in our progress on the project, at which point we will determine what items need to be worked on next and work will be divided up accordingly. Each individual team member will work on changes in their own branch and create a pull request when ready to merge. Pull requests that are being merged into main must be created with a descriptive title and description and a specific emoji is used in the title to signify the type of commit(i.e. update documentation, update/improve code, bug fix, etc.). Additionally test cases will be run automatically with GitHub Actions and any failed test cases will block merging. If all test cases pass, pull requests will still require 2 approving reviewers(separate from the original developer) to be merged into main. It will be expected that all of these steps are followed by all team members throughout the course of the project. \newline

\textbf{In Summary:}\\ \\
\textit{**group steps}
\begin{enumerate}[resume]
  \item Discuss current status of the project.
  \item Divide workload evenly.
  \end{enumerate}
\textit{**individual steps}
\begin{enumerate}[resume]
  \item Pull changes from main branch.
  \item Create new branch based on most up to date main branch.
  \item Carry out task dev work and testing as needed.
  \item Commit code with descriptive title including necessary emoji to imply the general purpose of the commit, and also add a descriptive commit description.
  \end{enumerate}
  \begin{adjustwidth}{1.3cm}{0cm}
  - Automated unit tests will be run. If any tests fail user must recommit to fix the issue.
  \end{adjustwidth}
\begin{enumerate}[resume]
  \item Two other team members review and approve the PR if no issues are noted.
  \end{enumerate}
  \begin{adjustwidth}{1.3cm}{0cm}
  - If reviewers find an issue they can request code changes at which point the developer must go back to step 6 and make a new commit to meet code review expectations.
  \end{adjustwidth}
\begin{enumerate}[resume]
  \item Merge code from main into user branch if user branch is out of date.
  \item Merge code into main branch.
\end{enumerate}

\section{Proof of Concept Demonstration Plan}

Developing an online multiplayer variant of Yahtzee presents several risks that could impact the success of the project. One significant risk is the inability to implement online multiplayer functionality with short response times, which is crucial for maintaining a smooth and enjoyable user experience, and to allow for simultaneous dice rolls. Delays or lags in response times could frustrate players and negatively affect gameplay, and hinder the player interaction that the game aims to provide. Another risk is not being able to correctly implement the complex Yahtzee scoring system, which could result in incorrect outcomes or unfair gameplay. Ensuring that the game accurately tracks scores according to the traditional rules is essential for user satisfaction. Finally, failing to implement the basic Yahtzee mechanics, such as rolling dice, re-rolling, and selecting scoring categories, could hinder the core gameplay. If these foundational elements are not properly developed, the entire game experience could become dysfunctional and unplayable. \\

To address the key risks in developing an online multiplayer Yahtzee variant, the proof of concept demo will focus on demonstrating the core functionality required to overcome these challenges. First, it should showcase the implementation of online multiplayer with fast response times, ensuring real-time interaction between players without noticeable lag. This will prove that the game can handle smooth, synchronized gameplay across different devices. Next, the demo must include a fully functional Yahtzee scoring system, correctly calculating scores for all possible combinations, like full house, straights, and Yahtzees, to show accuracy and reliability in scoring. Lastly, the demo should feature the basic Yahtzee mechanics, such as rolling dice, re-rolling up to two times, and selecting score categories, all working seamlessly. By focusing on these critical features, the demo will provide confidence that the project can overcome the identified risks and deliver a functional and enjoyable multiplayer experience.\\

\section{Expected Technology}

For this project, the online multiplayer variant of Yahtzee will be developed using the Godot game engine with GDScript as the primary programming language. GDScript is specifically designed for Godot and offers an easy-to-read, Python-like syntax, making it ideal for rapid game development and ensuring seamless integration with the Godot engine's core features. The Godot engine will provide the necessary framework for game physics, rendering, input handling, and networking, allowing us to focus on game-specific functionality such as the multiplayer interaction, Yahtzee mechanics, and scoring system. \\

External libraries may be utilized to support features such as real-time multiplayer synchronization and latency management. For example, Godot has built-in networking features, but depending on the complexity and performance requirements of the game, we may need to integrate additional libraries or APIs to enhance real-time communication between clients. As part of the development, we will implement certain major components ourselves, such as the Yahtzee scoring system and game logic, despite the existence of general-purpose libraries. This is because the game mechanics are fairly specific and require careful tuning to ensure proper scoring and gameplay flow, which can be more effectively managed through custom implementations. \\

For this project, Continuous Integration (CI) will primarily focus on documentation updates, ensuring that the project documentation is always up to date with the latest development changes. This will help streamline collaboration between team members and provide a clear and consistent understanding of the projectâ€™s current status. Documentation CI pipelines will automatically trigger when changes are made to files related to the design, development, or architecture, ensuring that our design documents, requirements, and user manuals are consistently aligned with the latest codebase. \\

Additionally, although CI can be more challenging in game development due to the graphical and interactive nature of the project, we will explore ways to incorporate CI practices into our development workflow. For example, we plan to investigate the feasibility of automated unit testing for core game logic, such as the Yahtzee mechanics, scoring system, and multiplayer interactions. While automated tests for graphical interfaces and real-time multiplayer can be difficult, CI could still help us ensure that the game logic functions correctly after every code change. By keeping CI lightweight and focused on these areas, we can ensure some level of automation without over-complicating the process, especially given the unique constraints of game development projects. \\

Performance measuring tools like Godot's built-in profiler will be used to monitor frame rates and resource consumption, critical for ensuring smooth, responsive multiplayer gameplay. Lastly, we will be using version control through Git, integrated with platforms like GitHub for collaboration, which will facilitate efficient management of code changes and team contributions. \\


\section{Coding Standard}


The coding guidelines below will allow for a uniform codebase and proper collaboration between developers. The guidelines are derived from Microsoft common C\# code conventions [1] which are universally accepted as industry standards.

\begin{itemize}

  \item Use ``int'' rather than unsigned types. \texttt{int} is commonly used in C\# and interacts more easily with other libraries. Exceptions apply only for documentation specific to unsigned data types. [1]
  \item Class and method names should always be in Pascal Case
  \begin{itemize}
    \item Ex: PascalCase
  \end{itemize}
  \item Method arguments and local variables should always be in Camel Case
  \begin{itemize}
    \item Ex: camelCase
  \end{itemize}
  \item Employ abstraction, encapsulation, inheritance and polymorphism

  \begin{itemize}
    \item Abstraction: Model the relevant attributes and interactions of entities as classes to define an abstract representation of a system. Use interfaces or abstract classes to provide a blueprint for other classes without revealing implementation details. [2]
    \item Encapsulation: Hide the internal state and functionality of an object, allowing access only through a public set of functions. Use private fields to hide an object's internal state. Provide public properties or methods (get and set) to access or modify the private fields in a controlled way, ensuring safe interaction with the object. [2]
    \item Inheritance: Create new abstractions based on existing abstractions. Reuse common functionality from the base class while allowing the derived class to add or override methods or properties. [2]
    \item Polymorphism: Implement inherited properties or methods in different ways across multiple abstractions. Use interfaces or abstract classes to define common methods that can be implemented differently in each class. [2]

  \end{itemize}

\item Use a reputable linter; all members should use the same linter
\item Write code with clarity and simplicity in mind
\item Avoid overly complex and convoluted code logic
\item Comments should be consice and to the point
\item Code should be formatted appropriately
\item Hard coded constants should be avaided, employ symbolic names and use configuration files 
\item Any code taken from external sources must be sufficiently cited through comments
\begin{itemize}
  \item Include links to webpages for any external resources
  \item Include input and output for any AI-aided code
\end{itemize}


\end{itemize}


\newpage

\section{Project Scheduling}

The team has decided to employ a Gantt chart to schedule the project. A Gantt chart provides a way to depict the duration, completion percentage, and leads of tasks in a visual manner. Due to these benefits, deadlines are met due to the duration of a task being enforced by start and end dates. It also allows for effective communication as others know who to refer to if there is an issue pertaining to a certain task due to the leads being listed. All in all, a Gantt chart provides great facilities to effectively plan out a project. \\

The team will also implement a backlog for our development which will be featured in our readme file on github to aid potential contributors. This will allow them to understand which features have been implemented and which are still in development. This will be in addition to utilizing GitHub project boards.\\

Gantt Chart: \href{https://mcmasteru365-my.sharepoint.com/:x:/g/personal/bhatth14_mcmaster_ca/ESjvjVJfZflPvcV8xfFiPxEBNGdj_fdNWy0EyGGiqIbAEw?e=9wUfQj}{Link}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741}

\input{../Reflection.tex}

\begin{enumerate}
    \item  \textbf {Why is it important to create a development plan prior to starting the
    project?}

    A development plan is essential when taking on any sort of project. It allows for the team to set a clear set of goals and milestones while also defining the project's scope. It creates a baseline of expectations for each team member and reduces any confusion about the team's plan as a high-level plan is detailed within the development plan. Without a development plan, a direction for the team is not set which in both the short and long term will cause issues that will eventually lead to missed deadlines and poor quality of work.
    
    \item  \textbf {In your opinion, what are the advantages and disadvantages of using
    CI/CD?}

    In our scenario, the team is creating a game using Godot, an open-source game engine. Therefore, there are some issues that present themselves. One is, performing automated testing, as it is more complex due to the need for graphical tests and user input simulations, which aren't easily automated in standard CI/CD pipelines. Another issue with CI/CD is that they are complex to set up and maintain as the system must remain updated, secure, and functional.

    However, there are still benefits to employing CI/CI pipelines as it promotes collaboration. Everyone is always working on the most up-to-date version which reduces commit conflicts and new features not working due to code logic being altered in an unpulled commit. It also allows new features and fixes to be pushed to production more quickly and reliably which enhances software quality and user satisfaction.

    Overall, implementing Continuous Integration (CI) and Continuous Deployment does provide a sizable benefit to most projects. However, as mentioned above, it cannot be used in certain circumstances. It may be ideal but it is not feasible. In the team's case, CI/CD may not be beneficial and impractical but we can still use aspects of CI/CD in our methodology.    
    \item  \textbf {What disagreements did your group have in this deliverable, if any,
    and how did you resolve them?}

    When constructing the development plan, the team faced no disagreements. Due to the area of the project being outside of our expertise, the team was open to suggestions on how the project could be developed. Due to close to zero experience in game development, when researching important tools that would be used to develop the game such as what game engine to use we were able to go off separately on our own and research the pros and cons of certain game engines such as Unity and Godot. Doing this allowed each member to understand the pros and cons of different game engines and we were then able to conclude which game engine to use without much issue. This was the way the team approached any aspect of the deliverable, which ultimately led to the completion of the deliverable without any issues.\end{enumerate}

\newpage{}

\section*{Appendix --- References}

\begin{flushleft}
  [1] B. Wagner, "C\# Coding Conventions," \textit{learn.microsoft.com}, Available: \url{https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions}.
  \newline
  [2] B. Wagner, "Object-Oriented Programming C\#," \textit{learn.microsoft.com}, Available: \url{https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/oop}.
\end{flushleft}

\end{document}